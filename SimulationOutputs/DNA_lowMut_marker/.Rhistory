# Common
common <- length(which(unique(names(which(wildFreqs > 5))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs > 5))))*100
# Low frequency
lowFrequency <- length(which(unique(names(which(wildFreqs < 10 & wildFreqs > 1))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs < 10 & wildFreqs > 1))))*100
# Rare
rare <- length(which(unique(names(which(wildFreqs < 1 & wildFreqs > 0))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs < 1 & wildFreqs > 0))))*100
# Build list of rates
captureRates <- c(total,veryCommon,common,lowFrequency,rare)
names(captureRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print capture rates and return
return(captureRates)
}
# Function for reporting allelic capture rates, using two genind objects (one for garden, one for wild)
reportAllelicCapture_Separate <- function(gen.obj.garden, gen.obj.wild){
# Build the wild allele frequency vector
wildFreqs <- colSums(gen.obj.wild@tab, na.rm = TRUE)/(nInd(gen.obj.wild)*2)*100
# Calculate capture rates
# Total
total <- length(which(names(which(wildFreqs > 0)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs > 0))*100
# Very common
veryCommon <- length(which(names(which(wildFreqs > 10)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs > 10))*100
# Common
common <- length(which(names(which(wildFreqs > 5)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs > 5))*100
# Low frequency
lowFrequency <- length(which(names(which(wildFreqs < 10 & wildFreqs > 1)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs < 10 & wildFreqs > 1))*100
# Rare
rare <- length(which(names(which(wildFreqs < 1 & wildFreqs > 0)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs < 1 & wildFreqs > 0))*100
# Build list of rates
captureRates <- c(total,veryCommon,common,lowFrequency,rare)
names(captureRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print capture rates and return
return(captureRates)
}
# Function for reporting allelic capture rates, using two genind objects (one for garden, one for wild)
# This version of the function strips the characters following the underscore, from the allele names
# Therefore, only whole RAD loci are being compared across garden and wild individuals
reportAllelicCapture_Separate_Partial <- function(gen.obj.garden, gen.obj.wild){
# Build the wild allele frequency vector
wildFreqs <- colSums(gen.obj.wild@tab, na.rm = TRUE)/(nInd(gen.obj.wild)*2)*100
# Rename wild frequencies, dropping the portion of allele names following the underscore
names(wildFreqs) <- gsub(pattern = "_[0-9]{1,4}.[0-9]{1,2}", replacement = "", names(wildFreqs))
# Rename garden colnames, dropping the portion of allele names following the underscore
colnames(gen.obj.garden@tab) <- gsub(pattern = "_[0-9]{1,4}.[0-9]{1,2}", replacement = "", colnames(gen.obj.garden@tab))
# Calculate capture rates
# Total
total <- length(which(unique(names(which(wildFreqs > 0))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs > 0))))*100
# Very common
veryCommon <- length(which(unique(names(which(wildFreqs > 10))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs > 10))))*100
# Common
common <- length(which(unique(names(which(wildFreqs > 5))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs > 5))))*100
# Low frequency
lowFrequency <- length(which(unique(names(which(wildFreqs < 10 & wildFreqs > 1))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs < 10 & wildFreqs > 1))))*100
# Rare
rare <- length(which(unique(names(which(wildFreqs < 1 & wildFreqs > 0))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs < 1 & wildFreqs > 0))))*100
# Build list of rates
captureRates <- c(total,veryCommon,common,lowFrequency,rare)
names(captureRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print capture rates and return
return(captureRates)
}
# R0, FIRST SNP----
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/denovo_finalAssemblies/QUAC/output/populations_R0_NOMAF_1SNP/"
setwd(genpop.filePath)
QUAC.R0_NOMAF_1SNP.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# R0, FIRST SNP----
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/denovo_finalAssemblies/QUAC/output/populations_R0_NOMAF_1SNP/"
setwd(genpop.filePath)
QUAC.R0_NOMAF_1SNP.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUAC.R0_NOMAF_1SNP.genind) <- factor(read.table("QUAC_popmap2", header=FALSE)[,2])
# Capture rates
reportAllelicCapture_Together(QUAC.R0_NOMAF_1SNP.genind)
reportAllelicCapture_Together_Partial(QUAC.R0_NOMAF_1SNP.genind)
# R0, TWO POPULATIONS, FIRST SNP----
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/denovo_finalAssemblies/QUAC/output/populations_R0_NOMAF_1SNP/"
setwd(genpop.filePath)
QUAC.R0_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUAC.R0_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUAC_popmap_GardenWild", header=FALSE)[,2])
list.files()
# R0, TWO POPULATIONS, FIRST SNP----
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/denovo_finalAssemblies/QUAC/output/populations_R0_NOMAF_1SNP_2Pops/"
setwd(genpop.filePath)
QUAC.R0_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUAC.R0_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUAC_popmap_GardenWild", header=FALSE)[,2])
# Capture rates
reportAllelicCapture_Together(QUAC.R0_NOMAF_1SNP.TwoPops.genind)
reportAllelicCapture_Together_Partial(QUAC.R0_NOMAF_1SNP.TwoPops.genind)
# Capture rates
reportAllelicCapture_Together(QUAC.R0_NOMAF_1SNP.genind)
# R0, FIRST SNP----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R0_NOMAF_1SNP"
setwd(genpop.filePath)
QUBO.R0_NOMAF_1SNP.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# R0, FIRST SNP----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R0_NOMAF_1SNP"
setwd(genpop.filePath)
QUBO.R0_NOMAF_1SNP.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# R0, FIRST SNP----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R0_NOMAF_1SNP/"
setwd(genpop.filePath)
QUBO.R0_NOMAF_1SNP.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUBO.R0_NOMAF_1SNP.genind) <- factor(read.table("QUBO_popmap2", header=FALSE)[,2])
# R0_NOMAF Capture rates
reportAllelicCapture_Together(QUBO.R0_NOMAF_1SNP.genind)
# R0, TWO POPULATIONS, FIRST SNP ----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R0_NOMAF_1SNP_2Pops/"
setwd(genpop.filePath)
QUBO.R0_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUBO.R0_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUBO_popmap_GardenWild", header=FALSE)[,2])
# R0_NOMAF Capture rates
reportAllelicCapture_Together(QUBO.R0_NOMAF_1SNP.TwoPops.genind)
# Capture rates
reportAllelicCapture_Together(QUAC.R0_NOMAF_1SNP.genind)
# Capture rates
reportAllelicCapture_Together(QUAC.R0_NOMAF_1SNP.TwoPops.genind)
# R0_NOMAF Capture rates
reportAllelicCapture_Together(QUBO.R0_NOMAF_1SNP.genind)
# R0_NOMAF Capture rates
reportAllelicCapture_Together(QUBO.R0_NOMAF_1SNP.TwoPops.genind)
nLoc(QUAC.R0_NOMAF_1SNP.genind)
nLoc(QUAC.R0_NOMAF_1SNP.TwoPops.genind)
nLoc(QUBO.R0_NOMAF_1SNP.genind)
nLoc(QUBO.R0_NOMAF_1SNP.TwoPops.genind)
# R0, TWO POPULATIONS ----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R0_NOMAF_TwoPops/"
setwd(genpop.filePath)
QUBO.R0_NOMAF_TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUBO.R0_NOMAF_TwoPops.genind) <- factor(read.table("QUBO_popmap_GardenWild", header=FALSE)[,2])
# R0_NOMAF Capture rates
reportAllelicCapture_Together(QUBO.R0_NOMAF_TwoPops.genind)
reportAllelicCapture_Together_Partial(QUBO.R0_NOMAF_TwoPops.genind)
nLoc(QUBO.R0_NOMAF_TwoPops.genind)
nLoc(QUBO.R0_NOMAF_1SNP.genind)
nLoc(QUBO.R0_NOMAF_1SNP.TwoPops.genind)
# R80, TWO POPULATIONS, FIRST SNP ----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/denovo_finalAssemblies/QUAC/output/populations_R80_NOMAF_1SNP_2Pops/"
setwd(genpop.filePath)
QUAC.R80_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUAC.R80_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUAC_popmap2", header=FALSE)[,2])
# Correct popNames
pop(QUAC.R80_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUAC_popmap_GardenWild", header=FALSE)[,2])
# R80_NOMAF Representation rates
reportAllelicRepresentation_Together(QUAC.R80_NOMAF_1SNP.TwoPops.genind)
# Function for reporting allelic representation rates, using a single genind object
reportAllelicRepresentation_Together <- function(gen.obj){
# Generate numberical vectors corresponding to garden and wild rows, for later calculations
garden.Rows <- seq_len(length(which(pop(gen.obj)=="garden")))
wild.Rows <- seq(from=length(which(pop(gen.obj)=="garden"))+1, to=nInd(gen.obj))
garden.N <- length(garden.Rows)
wild.N <- length(wild.Rows)
# Build the wild allele frequency vector
wildFreqs <- colSums(gen.obj@tab[wild.Rows,], na.rm = TRUE)/(wild.N*2)*100
# Calculate representation rates
# Total
total <- length(which(names(which(wildFreqs > 0)) %in% names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0))))/length(which(wildFreqs > 0))*100
# Very common
veryCommon <- length(which(names(which(wildFreqs > 10)) %in% names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0))))/length(which(wildFreqs > 10))*100
# Common
common <- length(which(names(which(wildFreqs > 5)) %in% names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0))))/length(which(wildFreqs > 5))*100
# Low frequency
lowFrequency <- length(which(names(which(wildFreqs < 10 & wildFreqs > 1)) %in% names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0))))/length(which(wildFreqs < 10 & wildFreqs > 1))*100
# Rare
rare <- length(which(names(which(wildFreqs < 1 & wildFreqs > 0)) %in% names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0))))/length(which(wildFreqs < 1 & wildFreqs > 0))*100
# Build list of rates
repRates <- c(total,veryCommon,common,lowFrequency,rare)
names(repRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print representation rates and return
return(repRates)
}
# Function for reporting allelic representation rates, using a single genind object
# This version of the function strips the characters following the underscore, from the allele names
# Therefore, only whole RAD loci are being compared across garden and wild individuals
reportAllelicRepresentation_Together_Partial <- function(gen.obj){
# Generate numberical vectors corresponding to garden and wild rows, for later calculations
garden.Rows <- seq_len(length(which(pop(gen.obj)=="garden")))
wild.Rows <- seq(from=length(which(pop(gen.obj)=="garden"))+1, to=nInd(gen.obj))
garden.N <- length(garden.Rows)
wild.N <- length(wild.Rows)
# Rename wild frequencies, dropping the portion of allele names following the underscore
colnames(gen.obj@tab) <- gsub(pattern = "_[0-9]{1,4}.[0-9]{1,2}", replacement = "", colnames(gen.obj@tab))
# Build the wild allele frequency vector
wildFreqs <- colSums(gen.obj@tab[wild.Rows,], na.rm = TRUE)/(wild.N*2)*100
# Calculate representation rates
# Total
total <- length(which(unique(names(which(wildFreqs > 0))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs > 0))))*100
# Very common
veryCommon <- length(which(unique(names(which(wildFreqs > 10))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs > 10))))*100
# Common
common <- length(which(unique(names(which(wildFreqs > 5))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs > 5))))*100
# Low frequency
lowFrequency <- length(which(unique(names(which(wildFreqs < 10 & wildFreqs > 1))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs < 10 & wildFreqs > 1))))*100
# Rare
rare <- length(which(unique(names(which(wildFreqs < 1 & wildFreqs > 0))) %in% unique(names(which(colSums(gen.obj@tab[garden.Rows,], na.rm = TRUE) > 0)))))/length(unique(names(which(wildFreqs < 1 & wildFreqs > 0))))*100
# Build list of rates
repRates <- c(total,veryCommon,common,lowFrequency,rare)
names(repRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print representation rates and return
return(repRates)
}
# Function for reporting allelic representation rates, using two genind objects (one for garden, one for wild)
reportAllelicRepresentation_Separate <- function(gen.obj.garden, gen.obj.wild){
# Build the wild allele frequency vector
wildFreqs <- colSums(gen.obj.wild@tab, na.rm = TRUE)/(nInd(gen.obj.wild)*2)*100
# Calculate representation rates
# Total
total <- length(which(names(which(wildFreqs > 0)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs > 0))*100
# Very common
veryCommon <- length(which(names(which(wildFreqs > 10)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs > 10))*100
# Common
common <- length(which(names(which(wildFreqs > 5)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs > 5))*100
# Low frequency
lowFrequency <- length(which(names(which(wildFreqs < 10 & wildFreqs > 1)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs < 10 & wildFreqs > 1))*100
# Rare
rare <- length(which(names(which(wildFreqs < 1 & wildFreqs > 0)) %in% colnames(gen.obj.garden@tab)))/length(which(wildFreqs < 1 & wildFreqs > 0))*100
# Build list of representation rates
repRates <- c(total,veryCommon,common,lowFrequency,rare)
names(repRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print representation rates and return
return(repRates)
}
# Function for reporting allelic representation rates, using two genind objects (one for garden, one for wild)
# This version of the function strips the characters following the underscore, from the allele names
# Therefore, only whole RAD loci are being compared across garden and wild individuals
reportAllelicRepresentation_Separate_Partial <- function(gen.obj.garden, gen.obj.wild){
# Build the wild allele frequency vector
wildFreqs <- colSums(gen.obj.wild@tab, na.rm = TRUE)/(nInd(gen.obj.wild)*2)*100
# Rename wild frequencies, dropping the portion of allele names following the underscore
names(wildFreqs) <- gsub(pattern = "_[0-9]{1,4}.[0-9]{1,2}", replacement = "", names(wildFreqs))
# Rename garden colnames, dropping the portion of allele names following the underscore
colnames(gen.obj.garden@tab) <- gsub(pattern = "_[0-9]{1,4}.[0-9]{1,2}", replacement = "", colnames(gen.obj.garden@tab))
# Calculate representation rates
# Total
total <- length(which(unique(names(which(wildFreqs > 0))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs > 0))))*100
# Very common
veryCommon <- length(which(unique(names(which(wildFreqs > 10))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs > 10))))*100
# Common
common <- length(which(unique(names(which(wildFreqs > 5))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs > 5))))*100
# Low frequency
lowFrequency <- length(which(unique(names(which(wildFreqs < 10 & wildFreqs > 1))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs < 10 & wildFreqs > 1))))*100
# Rare
rare <- length(which(unique(names(which(wildFreqs < 1 & wildFreqs > 0))) %in% unique(colnames(gen.obj.garden@tab))))/length(unique(names(which(wildFreqs < 1 & wildFreqs > 0))))*100
# Build list of representation rates
repRates <- c(total,veryCommon,common,lowFrequency,rare)
names(repRates) <- c("Total","Very common (>10%)","Common (>5%)","Low frequency (1% -- 10%)","Rare (<1%)")
# Print representation rates and return
return(repRates)
}
# R80_NOMAF Representation rates
reportAllelicRepresentation_Together(QUAC.R80_NOMAF_1SNP.TwoPops.genind)
# R80, TWO POPULATIONS, FIRST SNP ----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R80_NOMAF_AllSNPs/"
setwd(genpop.filePath)
QUBO.R80_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUBO.R80_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUBO_popmap_GardenWild", header=FALSE)[,2])
list.files()
# R80, TWO POPULATIONS, FIRST SNP ----
# Read in genind file
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/reference_filteredReads/QUBO/GSNAP4/output/populations_R80_NOMAF_1SNP_2Pops//"
setwd(genpop.filePath)
QUBO.R80_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUBO.R80_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUBO_popmap_GardenWild", header=FALSE)[,2])
# R80_NOMAF Representation rates
reportAllelicRepresentation_Together(QUBO.R80_NOMAF_1SNP.TwoPops.genind)
nLoc(QUBO.R80_NOMAF_1SNP.TwoPops.genind)
# R80_NOMAF Representation rates
reportAllelicRepresentation_Together(QUAC.R80_NOMAF_1SNP.TwoPops.genind)
nLoc(QUAC.R80_NOMAF_1SNP.TwoPops.genind)
ls()
# R0, TWO POPULATIONS, FIRST SNP----
genpop.filePath <-
"/RAID1/IMLS_GCCO/Analysis/Stacks/denovo_finalAssemblies/QUAC/output/populations_R0_NOMAF_1SNP_2Pops/"
setwd(genpop.filePath)
QUAC.R0_NOMAF_1SNP.TwoPops.genind <- read.genepop(paste0(genpop.filePath,"populations.snps.gen"), quiet = TRUE)
# Correct popNames
pop(QUAC.R0_NOMAF_1SNP.TwoPops.genind) <- factor(read.table("QUAC_popmap_GardenWild", header=FALSE)[,2])
388/2
nInd(QUAC.R0_NOMAF_1SNP.TwoPops.genind)
library(strataG)
library(adegenet)
clr()
library(stringr)
library(hierfstat)
setwd("~/Documents/SSRvSNP/Simulations/Code/fscParams/")
# ---- CONVERT ARLEQUIN FILES TO GENIND ----
# Function converting Arlequin output to genind (through gtypes format)
arp2genind <- function(params, repNumber, marker){
# Read in the Arlequin file, convert it to a gtype object, then to a genind object
arp <- fscReadArp(params, sim=c(1,repNumber), marker = marker)
gtype <- df2gtypes(arp, ploidy = 2)
genind <- gtypes2genind(gtype)
return(genind)
}
# TO DO: reformat this convertAllArp function to pass a vector of repNumbers to arp2gen, to use with lapply
# Function for converting ALL Arlequin files in a specified directory (using above arp2genind fxn)
# Outputs a list of genind objects, where each list item is a replicate
convertAllArp <- function(arp.path){
# Retrieve original working directory, to reset to after conversion
original.WD <- getwd()
# Navigate to the folder containing simulation outputs
setwd(arp.path)
# Create an empty list object to receive list of genind
genind.list <- list(length=length(dir()[str_detect(dir(), pattern = ".arp")]))
# Convert all Arlequin files to adegenet, creating a list of genind objects
for(i in 1:length(genind.list)){
genind.list[[i]] <- strataG_arp2gen()
}
genind.list <- lapply(dir()[str_detect(dir(), pattern = ".arp")], strataG_arp2gen)
# Reset to original working directory, and return a list of genind objects
setwd(original.WD)
return(genind.list)
}
# This is close, but the sim argument...we need to make a list,
# A list similar to lapply(seq(1:5), function(x) c(x,1)), except items in reverse order...
sapply(MSAT_01pop_migLow.params, fscReadArp, sim=c(1,seq(1:5)))
# ---- VARIABLES ----
num_reps <- 5
fscVersion <- "fsc2709"
# DEMES
# Specify number of total individuals, for all simulations
# Since there are 4 deme and 16 deme scenarios, this value must be divisible by 4 and 16
nInd <- 1200
# 1 Population
demeA <- fscDeme(deme.size = nInd, sample.size = nInd)
demes1 <- fscSettingsDemes(demeA)
# 4 Populations
demeB_1 <- fscDeme(deme.size = nInd/4, sample.size = nInd/4)
demeB_2 <- fscDeme(deme.size = nInd/4, sample.size = nInd/4)
demeB_3 <- fscDeme(deme.size = nInd/4, sample.size = nInd/4)
demeB_4 <- fscDeme(deme.size = nInd/4, sample.size = nInd/4)
demes4 <- fscSettingsDemes(demeB_1, demeB_2, demeB_3, demeB_4)
# 16 Populations
demeC_1 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_2 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_3 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_4 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_5 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_6 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_7 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_8 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_9 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_10 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_11 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_12 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_13 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_14 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_15 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demeC_16 <- fscDeme(deme.size = nInd/16, sample.size = nInd/16)
demes16 <- fscSettingsDemes(demeC_1,demeC_2,demeC_3,demeC_4,demeC_5,demeC_6,demeC_7,demeC_8,demeC_9,demeC_10,demeC_11,demeC_12,
demeC_13,demeC_14,demeC_15,demeC_16)
# MIGRATION
low_mig <- 0.001
high_mig <- 0.01
mig.mat.4.Low <- matrix(low_mig, nrow=4, ncol = 4); diag(mig.mat.4.Low) <- 0
mig.mat.4.High <- matrix(high_mig, nrow=4, ncol = 4); diag(mig.mat.4.High) <- 0
mig.mat.4.Final <- matrix(0, nrow=4, ncol = 4)
mig4Low <- fscSettingsMigration(mig.mat.4.Low, mig.mat.4.Final)
mig4High <- fscSettingsMigration(mig.mat.4.High, mig.mat.4.Final)
mig.mat.16.Low <- matrix(low_mig, nrow=16, ncol = 16); diag(mig.mat.16.Low) <- 0
mig.mat.16.High <- matrix(high_mig, nrow=16, ncol = 16); diag(mig.mat.16.High) <- 0
mig.mat.16.Final <- matrix(0, nrow=16, ncol = 16)
mig16Low <- fscSettingsMigration(mig.mat.16.Low, mig.mat.16.Final)
mig16High <- fscSettingsMigration(mig.mat.16.High, mig.mat.16.Final)
# Historical events
hist.event0 <- fscEvent(event.time = 50000, source = 0, sink = 0, prop.migrants = 0, migr.mat = 1)
hist.event1 <- fscEvent(event.time = 50000, source = 1, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event2 <- fscEvent(event.time = 50000, source = 2, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event3 <- fscEvent(event.time = 50000, source = 3, sink = 0, prop.migrants = 1, migr.mat = 1)
histEvent4 <- fscSettingsEvents(hist.event0, hist.event1, hist.event2, hist.event3)
hist.event4 <- fscEvent(event.time = 50000, source = 4, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event5 <- fscEvent(event.time = 50000, source = 5, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event6 <- fscEvent(event.time = 50000, source = 6, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event7 <- fscEvent(event.time = 50000, source = 7, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event8 <- fscEvent(event.time = 50000, source = 8, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event9 <- fscEvent(event.time = 50000, source = 9, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event10 <- fscEvent(event.time = 50000, source = 10, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event11 <- fscEvent(event.time = 50000, source = 11, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event12 <- fscEvent(event.time = 50000, source = 12, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event13 <- fscEvent(event.time = 50000, source = 13, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event14 <- fscEvent(event.time = 50000, source = 14, sink = 0, prop.migrants = 1, migr.mat = 1)
hist.event15 <- fscEvent(event.time = 50000, source = 15, sink = 0, prop.migrants = 1, migr.mat = 1)
histEvent16 <- fscSettingsEvents(hist.event0,hist.event1,hist.event2,hist.event3,hist.event4,hist.event5,hist.event6,hist.event7,
hist.event8,hist.event9,hist.event10,hist.event11,hist.event12,hist.event13,hist.event14,hist.event15)
# MSAT Genetic parameters
msats <- fscBlock_microsat(num.loci = 1, mut.rate = 5e-4, range.constraint = 10)
MSATgenetics <- fscSettingsGenetics(msats, num.chrom = 20)
# DNA Genetic parameters
dna <- fscBlock_dna(sequence.length = 25, mut.rate = 1e-5)
DNAgenetics <- fscSettingsGenetics(dna, dna, dna, dna, num.chrom = 5)
# ---- MICROSATELLITE SIMULATIONS ----
setwd("~/Documents/SSRvSNP/Simulations/Code/fscParams/MSAT_marker/")
# 1 POPULATION ----
# Write parameter files. We make a mighHigh .par file as well, even though it's identical to migLow (with one population)
MSAT_01pop_migLow.params <- fscWrite(demes = demes1, genetics = MSATgenetics, label = "MSAT_01pop_migLow", use.wd=TRUE)
MSAT_01pop_migHigh.params <- fscWrite(demes = demes1, genetics = MSATgenetics, label = "MSAT_01pop_migHigh", use.wd=TRUE)
# Run parameter files
MSAT_01pop_migLow.params <- fscRun(MSAT_01pop_migLow.params, num.sims = num_reps, exec = fscVersion)
MSAT_01pop_migHigh.params <- fscRun(MSAT_01pop_migHigh.params, num.sims = num_reps, exec = fscVersion)
# 4 POPULATIONS ----
# Write parameter files
MSAT_04pop_migLow.params <- fscWrite(demes = demes4, migration = mig4Low, events = histEvent4,
genetics = MSATgenetics, label = "MSAT_04pop_migLow", use.wd=TRUE)
MSAT_04pop_migHigh.params <- fscWrite(demes = demes4, migration = mig4High, events = histEvent4,
genetics = MSATgenetics, label = "MSAT_04pop_migHigh", use.wd=TRUE)
# Run parameter files
MSAT_04pop_migLow.params <- fscRun(MSAT_04pop_migLow.params, num.sims = num_reps, exec = fscVersion)
MSAT_04pop_migHigh.params <- fscRun(MSAT_04pop_migHigh.params, num.sims = num_reps, exec = fscVersion)
# 16 POPULATIONS ----
# Write parameter files
MSAT_16pop_migLow.params <- fscWrite(demes = demes16, migration = mig16Low, events = histEvent16,
genetics = MSATgenetics, label = "MSAT_16pop_migLow", use.wd=TRUE)
MSAT_16pop_migHigh.params <- fscWrite(demes = demes16, migration = mig16High, events = histEvent16,
genetics = MSATgenetics, label = "MSAT_16pop_migHigh", use.wd=TRUE)
# Run parameter files
MSAT_16pop_migLow.params <- fscRun(MSAT_16pop_migLow.params, num.sims = num_reps, exec = fscVersion)
MSAT_16pop_migHigh.params <- fscRun(MSAT_16pop_migHigh.params, num.sims = num_reps, exec = fscVersion)
# ---- DNA SIMULATIONS ----
setwd("~/Documents/SSRvSNP/Simulations/Code/fscParams/DNA_marker/")
# 1 POPULATION ----
# Write parameter files. We make a mighHigh .par file as well, even though it's identical to migLow (with one population)
DNA_01pop_migLow.params <- fscWrite(demes = demes1, genetics = DNAgenetics, label = "DNA_01pop_migLow", use.wd=TRUE)
DNA_01pop_migHigh.params <- fscWrite(demes = demes1, genetics = DNAgenetics, label = "DNA_01pop_migHigh", use.wd=TRUE)
# Run parameter files
DNA_01pop_migLow.params <- fscRun(DNA_01pop_migLow.params, num.sims = num_reps, all.sites = TRUE, exec = fscVersion)
DNA_01pop_migHigh.params <- fscRun(DNA_01pop_migHigh.params, num.sims = num_reps, all.sites = TRUE, exec = fscVersion)
# 4 POPULATIONS ----
# Write parameter files
DNA_04pop_migLow.params <- fscWrite(demes = demes4, migration = mig4Low, events = histEvent4,
genetics = DNAgenetics, label = "DNA_04pop_migLow", use.wd=TRUE)
DNA_04pop_migHigh.params <- fscWrite(demes = demes4, migration = mig4High, events = histEvent4,
genetics = DNAgenetics, label = "DNA_04pop_migHigh", use.wd=TRUE)
# Run parameter files
DNA_04pop_migLow.params <- fscRun(DNA_04pop_migLow.params, num.sims = num_reps, all.sites = TRUE, exec = fscVersion)
DNA_04pop_migHigh.params <- fscRun(DNA_04pop_migHigh.params, num.sims = num_reps, all.sites = TRUE, exec = fscVersion)
# 16 POPULATIONS ----
# Write parameter files
DNA_16pop_migLow.params <- fscWrite(demes = demes16, migration = mig16Low, events = histEvent16,
genetics = DNAgenetics, label = "DNA_16pop_migLow", use.wd=TRUE)
DNA_16pop_migHigh.params <- fscWrite(demes = demes16, migration = mig16High, events = histEvent16,
genetics = DNAgenetics, label = "DNA_16pop_migHigh", use.wd=TRUE)
# Run parameter files
DNA_16pop_migLow.params <- fscRun(DNA_16pop_migLow.params, num.sims = num_reps, all.sites = TRUE, exec = fscVersion)
DNA_16pop_migHigh.params <- fscRun(DNA_16pop_migHigh.params, num.sims = num_reps, all.sites = TRUE, exec = fscVersion)
# ---- CONVERT ARLEQUIN FILES TO GENIND ----
# Function converting Arlequin output to genind (through gtypes format)
arp2genind <- function(params, repNumber, marker){
# Read in the Arlequin file, convert it to a gtype object, then to a genind object
arp <- fscReadArp(params, sim=c(1,repNumber), marker = marker)
gtype <- df2gtypes(arp, ploidy = 2)
genind <- gtypes2genind(gtype)
return(genind)
}
# TO DO: reformat this convertAllArp function to pass a vector of repNumbers to arp2gen, to use with lapply
# Function for converting ALL Arlequin files in a specified directory (using above arp2genind fxn)
# Outputs a list of genind objects, where each list item is a replicate
convertAllArp <- function(arp.path){
# Retrieve original working directory, to reset to after conversion
original.WD <- getwd()
# Navigate to the folder containing simulation outputs
setwd(arp.path)
# Create an empty list object to receive list of genind
genind.list <- list(length=length(dir()[str_detect(dir(), pattern = ".arp")]))
# Convert all Arlequin files to adegenet, creating a list of genind objects
for(i in 1:length(genind.list)){
genind.list[[i]] <- strataG_arp2gen()
}
genind.list <- lapply(dir()[str_detect(dir(), pattern = ".arp")], strataG_arp2gen)
# Reset to original working directory, and return a list of genind objects
setwd(original.WD)
return(genind.list)
}
# This is close, but the sim argument...we need to make a list,
# A list similar to lapply(seq(1:5), function(x) c(x,1)), except items in reverse order...
sapply(MSAT_01pop_migLow.params, fscReadArp, sim=c(1,seq(1:5)))
# Function converting Arlequin output to genind (through gtypes format)
strataG_arp2gen <- function(params, repNumber, marker){
# Read in the Arlequin file, convert it to a gtype object, then to a genind object
arp <- fscReadArp(params, sim=c(1,repNumber), marker = marker)
gtype <- df2gtypes(arp, ploidy = 2)
genind <- gtypes2genind(gtype)
return(genind)
}
MSAT_01pop_migLow.params
MSAT_01pop_migLow.params$settings$genetics$fsc.type
?fscReadArp()
tolower(MSAT_01pop_migLow.params$settings$genetics$fsc.type)
